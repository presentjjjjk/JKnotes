# 智能优化算法实例

## 遗传算法实例

本文档尝试将遗传算法应用于经典的优化问题，以提高笔者的熟练度。

### 背包问题

让GPT生成了一个例子，我们现在尝试用遗传算法来求解这个问题,虽然有点高射炮打蚊子，但是可以练练手。

![alt text](image-7.png)

```python

import random as rd

#先定义种群规模
N=100

#定义进化代数
n=0

zhongqun=[]

best_value=0
best=[]

for i in range(N):
    t=[]
    for i in range(3):
        t.append(rd.randint(0,1))
    zhongqun.append(t)

while True:
    #评价适应度
    #定义一个适应度数组
    value=[i for i in range(N)]
    for i in range(N):
        u=10*zhongqun[i][0]+20*zhongqun[i][1]+30*zhongqun[i][2]
        v=60*zhongqun[i][0]+100*zhongqun[i][1]+120*zhongqun[i][2]
        

        #淘汰掉生成的不合理个体
        if(u>50):
            value[i]=0
        else:
            value[i]=v
    

    #选择适应度最高的进行存储：
    best_value=max(value)
    best=zhongqun[value.index(best_value)]

    #设定概率：
    p=[value[i]/sum(value) for i in range(N)]

    #定义交配空间J
    J=[]


    i=0
    while True:
        if rd.random()<p[i]:
            J.append(zhongqun[i])
        if len(J)==N:
            break
        i += 1
        if i==N:
            i=0
    
    #设定交配概率
    p_0=0.85
    #定义一个交配数组J_0
    J_0=[]
    yubeizhongqun=[]

    for i in range(N):
        if rd.random()<p_0:
            J_0.append(J[i])
        else:
            yubeizhongqun.append(J[i])
    
    #然后再配对
    if len(J_0)==1 or len(J_0)==0:
        yubeizhongqun=J
    else:
        
        #单点配对交配
        i=0
        while(i<len(J_0)-1):
            k=rd.randint(0,2)
            J_0[i],J_0[i+1]=J_0[i][0:k]+J_0[i+1][k:],J_0[i+1][0:k]+J_0[i][k:]
            i=i+2
        
        yubeizhongqun +=J_0

        #变异，定义变异概率

        p_b=0.1

        for ele in yubeizhongqun:
            if rd.random()<p_b:
                k=rd.randint(0,2)
                ele[k]=1-ele[k]
        
        zhongqun=yubeizhongqun
        n=n+1

        if n>=100:
            break

print(f'bestvalue:{best_value:}')
print(f'best:{best:}')
        
            
        
```

运行结果为：

![alt text](image-8.png)

与预期结果一致，在运算过程中也发现，如果种群数目太少，可能迭代很多次都还没有收敛，如果种群数目太大，那么占据的计算资源过多，导致运算缓慢

下面是一个稍微复杂一点的例子：

![alt text](image-9.png)

我们只需要稍微修改一下代码：

```python

import random as rd

#先定义种群规模
N=100

#定义进化代数
n=0

zhongqun=[]

best_value=0
best=[]

weight=[4,3,1,5,2,1,3,2,4,3]
value_0=[300,200,150,500,200,100,250,300,350,400]

for i in range(N):
    t=[]
    for i in range(10):
        t.append(rd.randint(0,1))
    zhongqun.append(t)

while True:
    #评价适应度
    #定义一个适应度数组
    value=[i for i in range(N)]

    for i in range(N):
        u=sum([weight[j]*zhongqun[i][j] for j in range(10)])
        v=sum([value_0[j]*zhongqun[i][j] for j in range(10)])
        

        #淘汰掉生成的不合理个体
        if(u>10):
            value[i]=0
        else:
            value[i]=v
    

    #选择适应度最高的进行存储：
    best_value=max(value)
    best=zhongqun[value.index(best_value)]

    #设定概率：
    p=[value[i]/sum(value) for i in range(N)]

    #定义交配空间J
    J=[]


    i=0
    while True:
        if rd.random()<p[i]:
            J.append(zhongqun[i])
        if len(J)==N:
            break
        i += 1
        if i==N:
            i=0
    
    #设定交配概率
    p_0=0.85
    #定义一个交配数组J_0
    J_0=[]
    yubeizhongqun=[]

    for i in range(N):
        if rd.random()<p_0:
            J_0.append(J[i])
        else:
            yubeizhongqun.append(J[i])
    
    #然后再配对
    if len(J_0)==1 or len(J_0)==0:
        yubeizhongqun=J
    else:
        
        #单点配对交配
        i=0
        while(i<len(J_0)-1):
            k=rd.randint(0,9)
            J_0[i],J_0[i+1]=J_0[i][0:k]+J_0[i+1][k:],J_0[i+1][0:k]+J_0[i][k:]
            i=i+2
        
        yubeizhongqun +=J_0

        #变异，定义变异概率

        p_b=0.1

        for ele in yubeizhongqun:
            if rd.random()<p_b:
                k=rd.randint(0,9)
                ele[k]=1-ele[k]
        
        zhongqun=yubeizhongqun
        n=n+1

        if n>=100:
            break

print(f'bestvalue:{best_value:}')
print(f'best:{best:}')
        
            
 
```
得到的运行结果是：

![alt text](image-10.png)

完全正确！

### TSP问题

依旧是用GPT生成的题目

![alt text](image-11.png)

代码如下所示：

```python

import random as rd
from math import sqrt,exp

import matplotlib.pyplot as plt

#定义一个距离函数
def distance(i,j):
    dis=sqrt((zuobiao[i][0]-zuobiao[j][0])**2+(zuobiao[i][1]-zuobiao[j][1])**2)
    return dis

#先定义种群规模
N=500

#定义进化代数
n=0

zhongqun=[]

best_value=0
best=[]

#给定所有的城市坐标
zuobiao=[
    [0,0],[3,7],[5,1],[10,6],[7,2],[4,8],[9,3]
]

#生成种群
for i in range(N):
    t=[0]  #注意必须从0出发
    for i in range(6):
        t.append(rd.randint(1,6))
    zhongqun.append(t)

while True:
    #评价适应度
    #定义一个适应度数组,和种群规模一致
    value=[i for i in range(N)]

    for i in range(N):
        s=0
        for j in range(6):
            s=s+distance(zhongqun[i][j],zhongqun[i][j+1])
        s=s+distance(0,zhongqun[i][6])
        
    
        #评价函数需要修改，还要增加走过的城市数目,增加了一个修正项
        num=len(set(zhongqun[i]))
        value[i]=num/s




    #选择适应度最高的进行存储：
    best_value=max(value)
    best=zhongqun[value.index(best_value)]

    #设定概率：
    p=[value[i]/sum(value) for i in range(N)]

    #定义交配空间J
    J=[]


    i=0
    while True:
        if rd.random()<p[i]:
            J.append(zhongqun[i])
        if len(J)==N:
            break
        i += 1
        if i==N-1:
            i=0
    
    #设定交配概率
    p_0=0.9
    #定义一个交配数组J_0
    J_0=[]
    yubeizhongqun=[]

    for i in range(N):
        if rd.random()<p_0:
            J_0.append(J[i])
        else:
            yubeizhongqun.append(J[i])
    
    #然后再配对
    if len(J_0)==1 or len(J_0)==0:
        yubeizhongqun=J
    else:
        
        #单点配对交配
        i=0
        while(i<len(J_0)-1):
            k=rd.randint(1,6)
            J_0[i],J_0[i+1]=J_0[i][0:k]+J_0[i+1][k:],J_0[i+1][0:k]+J_0[i][k:]
            i=i+2
        
        yubeizhongqun +=J_0

        #变异，定义变异概率

        p_b=0.1

        for ele in yubeizhongqun:
            if rd.random()<p_b:
                k=rd.randint(1,6)
                ele[k]=rd.randint(1,6)
        
        zhongqun=yubeizhongqun
        n=n+1

        if n>=3000:
            break

print(f'bestvalue:{best_value:}')
print(f'best:{best:}')

plt.figure(1)

x=[zuobiao[i][0] for i in range(7)]
y=[zuobiao[i][1] for i in range(7)]

plt.scatter(x,y)

for i in range(6):
    plt.plot(
        [zuobiao[best[i]][0], zuobiao[best[i+1]][0]],  # X 坐标
        [zuobiao[best[i]][1], zuobiao[best[i+1]][1]]   # Y 坐标
    )
    
# 最后一条线段，从最后一个城市回到第一个城市
plt.plot(
    [zuobiao[best[6]][0], zuobiao[best[0]][0]],  # X 坐标
    [zuobiao[best[6]][1], zuobiao[best[0]][1]]   # Y 坐标
)

plt.show()
            
         
```

运行结果为：

![alt text](image-13.png)

航行轨迹为：

![alt text](image-12.png)

非常完美，美中不足的是算的太慢了。



## 禁忌搜索算法实例

### TSP问题

#### 邻域变换

首先我们考虑邻域变换的形式，对于任意的一个路径：

$$
j_1,j_2, \ldots ,j_i, \ldots ,j_k, \ldots ,j_n 
$$

任选其中的两个元素$j_i$和$j_k$，将他们互换顺序，得到：

$$
j_1,j_2, \ldots ,j_k, \ldots ,j_i, \ldots ,j_n 
$$

这样，最少会得到$n(n+1)/2$个邻居（因为有可能有重复的），当城市数目比较多的时候，所得到的邻域会非常大，所以我们在里面挑选50个作为我们的候选集合

#### 禁忌表和禁忌期限

禁忌表的长度通常按照城市数目的25%左右来确定，禁忌期限通常选用：

$$
t=[\sqrt{\frac{N(N+1)}{2}}]
$$

为邻居数目的开根号。同时，我们对以上禁忌期限进行一定的改进，让禁忌期限在迭代次数较小的时候比较小，这样能有利于扩大搜索空间，在迭代次数较大的时候比较大，这样能有利于他收敛到全局最优解：

$$
t=[\sqrt{\frac{N(N+1)}{2}}\exp(a\frac{n}{n_{\max}})]
$$

其中a是参数，可以根据效果进行调整

#### 特设准则


关于特赦准则，我们采取简化的策略，当禁忌表满了的时候，把最早加入禁忌表的元素踢出去，然后在禁忌表的末尾加入元素。

下面让GPT生成一个问题，准备开始写代码吧

![alt text](image-17.png)

```python
import random as rd
from math import sqrt,exp

import matplotlib.pyplot as plt

# 城市坐标列表
zuobiao = [
    (34.05, -118.25),
    (40.71, -74.01),
    (37.77, -122.42),
    (51.51, -0.13),
    (48.85, 2.35),
    (35.68, 139.65),
    (55.75, 37.62),
    (39.90, 116.40),
    (-33.87, 151.21),
    (-23.55, -46.63),
    (19.43, -99.13),
    (1.29, 103.85),
    (41.89, 12.49),
    (40.42, -3.70),
    (52.52, 13.40),
    (28.61, 77.21),
    (39.92, 32.85),
    (-26.20, 28.04),
    (35.68, -0.63),
    (-34.61, -58.38)
]

#定义一个距离函数
def distance(i,j):
    dis=sqrt((zuobiao[i][0]-zuobiao[j][0])**2+(zuobiao[i][1]-zuobiao[j][1])**2)
    return dis

#定义一个总长函数
def length(ele):
    l=0
    for i in range(len(ele)-1):
        l += distance(ele[i],ele[i+1])
    l += distance(ele[len(ele)-1],0)
    return l

#定义一个禁忌表table

table=[]

table_time=[]

#产生一个可行解，这里采用每次的局部最小，现在啥也没有，就是按照顺序的解

best_path=[i for i in range(20)]
best=length(best_path)

#定义迭代次数
n=0

max_n=1000

#定义禁忌期限

time=int(sqrt(19*(19-1)/2)*exp(n/max_n)/100)


while(n<max_n):

    #定义候选集合和候选字典

    houxuan=[]
    
    houxuan_dict={}

    #使用邻域变换生产候选集合

    value=[]


    while len(houxuan)<50:
        i=rd.randint(1,19)
        j=rd.randint(1,19)

        if i!=j and (i,j) not in table and (i,j) not in list(houxuan_dict.values()):

            ele=best_path[:]

            ele[i],ele[j]=ele[j],ele[i]

            houxuan.append(ele)

            value.append(length(ele))

            houxuan_dict[length(ele)]=(i,j)

    
        
        else:
            continue
        
    if(min(value)<best):

        best=min(value)

        best_path=houxuan[value.index(min(value))]

    #在禁忌表中添加元素

    if len(table) <= 9:
        table.append(houxuan_dict[min(value)][:])
        table_time.append(time)
    else:
        #特赦准则，如果禁忌表已经满了，就把最前面的那个踢出去
        table_time.pop(0)
        table.pop(0)
        table.append(houxuan_dict[min(value)][:])
        table_time.append(time)

    #减小禁忌时间
    # 使用索引倒序删除元素以避免遍历和删除冲突
    for i in range(len(table_time) - 1, -1, -1):
        table_time[i] -= 1
        if table_time[i] == 0:
            table_time.pop(i)
            table.pop(i)
            
    
    n=n+1

print(f'best{best:}')

print(f'best_path{best_path:}')

plt.figure(1)

x=[zuobiao[i][0] for i in range(20)]
y=[zuobiao[i][1] for i in range(20)]

plt.scatter(x,y)

for i in range(19):
    plt.plot(
        [zuobiao[best_path[i]][0], zuobiao[best_path[i+1]][0]],  # X 坐标
        [zuobiao[best_path[i]][1], zuobiao[best_path[i+1]][1]]   # Y 坐标
    )
    
# 最后一条线段，从最后一个城市回到第一个城市
plt.plot(
    [zuobiao[best_path[19]][0], zuobiao[best_path[0]][0]],  # X 坐标
    [zuobiao[best_path[19]][1], zuobiao[best_path[0]][1]]   # Y 坐标
)

plt.show()


```

运行效果不是很理想，可能我设计的也不是很好，导致每一次的输出都不太稳定，下面这个比较优的运行结果已经是多次运行后一个较好的结果了：

![alt text](image-18.png)


![alt text](image-19.png)


## 蚁群算法实例

### TSP

具体的流程已经在组合优化当中叙述过了，下面直接给出代码。

```python
import random as rd

from math import sqrt
import matplotlib.pyplot as plt

#定义蚂蚁个数

m=10

#给出城市坐标
zuobiao = [
    (34.05, -118.25),
    (40.71, -74.01),
    (37.77, -122.42),
    (51.51, -0.13),
    (48.85, 2.35),
    (35.68, 139.65),
    (55.75, 37.62),
    (39.90, 116.40),
    (-33.87, 151.21),
    (-23.55, -46.63),
    (19.43, -99.13),
    (1.29, 103.85),
    (41.89, 12.49),
    (40.42, -3.70),
    (52.52, 13.40),
    (28.61, 77.21),
    (39.92, 32.85),
    (-26.20, 28.04),
    (35.68, -0.63),
    (-34.61, -58.38)
]


#定义距离函数和总长函数

def distance(i:int,j:int):
    dis=sqrt((zuobiao[i][0]-zuobiao[j][0])**2+(zuobiao[i][1]-zuobiao[j][1])**2)
    return dis

def length(a:list):
    l=0
    for i in range(len(a)-1):
        l=l+distance(a[i],a[i+1])
    l=l+distance(a[-1],a[0])
    return l



#定义迭代次数和最大迭代次数

n=0
max_n=1000

#定义最短路径和最短路径长度

best_length=1000000000000
best_path=[]

#定义信息素浓度字典,初始化信息素，随便一个常数
tau={}

for i in range(20):
    for j in range(20):
        if i!=j:
            tau[(i,j)]=1




#定义蒸发率
r=0.1
#蒸发率

#定义概率参数
a=1
b=2
#b是启发参数，通常要大一点，a和b应该都要大于1，之前两个都设置小于1算法不收敛


while n<max_n:
    #定义所有蚂蚁的路径列表：

    ant_list_sum=[]

    #定义所有蚂蚁的边集的集合
    slide=[]

    for num_of_ant in range(m):
        #定义出发地点和路径列表
        t=rd.randint(0,19)
        path=[]
        path.append(t)


        while(len(path)<20):

            #定义一个转移概率字典，来决定蚂蚁的下一步决策
            p={}

            for j in range(20):
                if j not in path:
                    s=tau[(t,j)]**a*(1/distance(t,j))**b/(sum([tau[(t,k)]**a*(1/distance(t,k))**b for k in range(20) if k not in path]))
                    p[j]=s
            
            
            #用轮盘赌选法选取蚂蚁前往的下一个城市
            p_0=rd.random()

            # 我们把数轴按照概率进行划分
            cumulative_prob = 0.0
            for city, prob in p.items():
                cumulative_prob += prob
                if cumulative_prob >= p_0:
                    t = city
                    break
            
            path.append(t)
        
        #把这只蚂蚁加到路径集合当中去
        ant_list_sum.append(path)
        #定义一个k号蚂蚁的边集
        slide_k=[]
        for i in range(len(path)-1):
            slide_k.append((path[i],path[i+1]))
        slide_k.append((path[-1],path[0]))

        #把它加入到总边集合中去
        slide.append(slide_k)

    
    #所有的蚂蚁都跑了一边，现在更新信息素
    for i in range(20):
        for j in range(20):
            if i!=j:
                s=0
                for x in range(len(ant_list_sum)):
                    if (i,j) in slide[x] or (j,i) in slide[x]:
                        s=s+1/length(ant_list_sum[x])
                tau[(i,j)]=(1-r)*tau[(i,j)]+s
    
    n=n+1
    
    
    if min([length(path) for path in ant_list_sum])<best_length:
        best_length=min([length(path) for path in ant_list_sum])
        
        for path in ant_list_sum:
            if(length(path)==min([length(path) for path in ant_list_sum])):
                best_path=path[:]

print(f'best_length:{best_length:}')
print(f'best_path:{best_path:}')

plt.figure(1)

x=[zuobiao[i][0] for i in range(20)]
y=[zuobiao[i][1] for i in range(20)]

plt.scatter(x,y)

for i in range(19):
    plt.plot(
        [zuobiao[best_path[i]][0], zuobiao[best_path[i+1]][0]],  # X 坐标
        [zuobiao[best_path[i]][1], zuobiao[best_path[i+1]][1]]   # Y 坐标
    )
    
# 最后一条线段，从最后一个城市回到第一个城市
plt.plot(
    [zuobiao[best_path[19]][0], zuobiao[best_path[0]][0]],  # X 坐标
    [zuobiao[best_path[19]][1], zuobiao[best_path[0]][1]]   # Y 坐标
)

plt.show()

                
```

代码运算的结果如下：

![alt text](image-20.png)

![alt text](image-21.png)

这个算法的性能非常强大，用比较少的蚂蚁和迭代次数就能稳定的输出最优解，但是值得注意的是，参数一定要设定正确，不然会出现算法不收敛的情况。

![alt text](image-22.png)

